**Определение:**

**Сортировка выбором (Selection Sort)** — на каждом шаге алгоритма находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве.

**Анализ:**

**Внешний цикл for (int i = 0; i < arr.length; i++)**: проходит по всем позициям массива, которые нужно заполнить минимальными элементами

**Инициализация минимума int minIndex = i**: предполагает, что текущий элемент является минимальным в неотсортированной части

**Внутренний цикл поиска for (int j = i + 1; j < arr.length; j++)**:  Ищет минимальный элемент в неотсортированной части массива От i+1 до конца массива

**Оператор сравнения if (arr[j] < arr[minIndex])**: сравнивает текущий элемент с текущим минимумом, определяет является ли элемент новым минимумом

**Обновление минимума minIndex = j**: запоминает индекс нового минимального элемента

**Обмен элементов int temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp**: помещает найденный минимальный элемент на правильную позицию, 

**Временная сложность:**

 **Почему именно O(n²)**:
 
**Двойная вложенность циклов** - внешний цикл O(n), внутренний цикл в среднем O(n/2)

**Полный перебор** - алгоритм систематически просматривает все элементы для поиска минимума

**Независимость от входных данных** - сложность одинакова для лучшего, среднего и худшего случаев

**Квадратичный рост** - при увеличении n в 2 раза, время выполнения увеличивается в 4 раза

**Определение:**

**Сортировка обменом (пузырьком) (Bubble Sort)** — алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном
порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.

**Анализ:** 

**Оператор инициализации n = len(arr)**: определяет размер массива для контроля границ циклов

**Внешний цикл for i in range(n - 1)**: выполняется n-1 раз, так как после n-1 итераций последний элемент автоматически займет правильную позицию

**Внутренний цикл for j in range(n - i - 1)**: на каждой итерации внешнего цикла проходит по неотсортированной части массива, n - i - 1 с каждой итерацией область прохода уменьшается, так как максимальные элементы "всплывают" в конец

**Оператор сравнения if arr[j] > arr[j + 1]**: сравнивает соседние элементы для определения необходимости обмена

**Оператор обмена arr[j], arr[j + 1] = arr[j + 1], arr[j]**: меняет местами элементы, находящиеся в неправильном порядке


**Временная сложность**:  **O(n²)**

**Почему O(n²):** В худшем случае, как и сортировка выбором, требует n*(n-1)/2 сравнений и потенциальных обменов.

**Определение:**

**Сортировка вставками (Insertion Sort)** — алгоритм строит отсортированную часть списка,
постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и
перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место.

**Анализ:**

**Внешний цикл (for i in range(1, len(array)))** - проходит по всем элементам массива, начиная со второго элемента (индекс 1)

 **key = array[i]** - текущий элемент, который нужно вставить в правильную позицию

**Внутренний цикл (while j >= 0 and array[j] > key)**: сдвигает элементы, большие чем key, на одну позицию вправо, ищет правильную позицию для вставки key

 **array[j + 1] = key** - помещает ключевой элемент на найденную позицию

**Временная сложность:** **O(n²)** 

**Почему** **O(n²)**;  

Временная сложность зависит от внутреннего цикла while:

Обратно отсортированный массив: внутренний цикл проходит всю отсортированную часть → O(i) на элемент → O(n²) общая

**Определение:**

**Сортировка слиянием (Merge Sort)** — алгоритм состоит в разделении массива пополам,
сортировке половин и их слиянии.

**Анализ:**
1) **Разделение массива на части**
   
   **if (arr.length <= 1)** - базовый случай рекурсии

    **int mid = arr.length / 2** - находим середину массива

    **Arrays.copyOfRange(arr, 0, mid)** - копируем левую половину

    **Arrays.copyOfRange(arr, mid, arr.length)** - копируем правую половину
   
2) **Рекурсивная сортировка частей**

    **mergeSort(left)** - рекурсивный вызов для левой части

    **mergeSort(right)** - рекурсивный вызов для правой части

3) **Метод слияния (merge)**
  
   **int[] result = new int[left.length + right.length]** - создаем результирующий массив

    **while (i < left.length && j < right.length)** - пока есть элементы в обоих массивах

    **if (left[i] < right[j])** - сравнение элементов из двух массивов

4) **Добавление оставшихся элементов**

   **while (i < left.length)** - добавляем оставшиеся элементы из левого массива

    **while (j < right.length)** - добавляем оставшиеся элементы из правого массива

**Временная сложность:** O(n log n) 

**Почему O(n log n)**:

1) **Уровни рекурсии (log n)**:
   На каждом уровне массив делится пополам

   Количество уровней деления: log₂n

   Пример: для n=8 → 3 уровня (8→4→2→1)

2) **Слияние на каждом уровне (n)**

    На каждом уровне рекурсии выполняется слияние всех элементов

    Общее количество операций слияния на каждом уровне: O(n)
   
**Определение:**

**Сортировка Шелла (Shellsort)** — является модификацией сортировки вставками, сортирует
между собой элементы, стоящие на местах, кратных определённому шагу.

**Анализ:**

**Инициализация промежутка (gap)**:     

   **n = len(arr)** - получаем длину массива

   **gap = n // 2** - начальный промежуток (половина длины массива)
   
**Основной цикл с уменьшением промежутка**:  

**while gap > 0:** - продолжаем пока промежуток больше 0
    
**Проход по элементам с текущим промежутком**

 **for i in range(gap, n):** - проходим по всем элементам начиная с позиции gap

 **temp = arr[i]** - сохраняем текущий элемент

 **j = i** - устанавливаем индекс для сдвига

 
 **Сдвиг элементов и вставка**:
 
   **while j >= gap and arr[j - gap] > temp:** - пока не дошли до начала и элемент больше temp

   **arr[j] = arr[j - gap]** - сдвигаем элемент вправо

   **j -= gap** - перемещаемся на промежуток назад

   **arr[j] = temp** - вставляем сохраненный элемент на правильное место
 
**Временная сложность:** **O(n²)**

**Почему** **O(n²)**:  

**Внешний цикл (уменьшение gap)**:     

Количество итераций: O(log n)

Пример: для n=8 → gap: 4, 2, 1 → 3 итерации (log₂8 = 3)

**Внутренний цикл (проход по элементам)**:

  Для каждого gap выполняется O(n) операций

**Определение:**

**Быстрая сортировка (Quick Sort)** — один из самых известных и широк используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них.

**Анализ:**

**Выбор опорного элемента:** 

В данной реализации выбирается последний элемент массива pivot = array[high]

**Разбиение (partition):**

Массив переупорядочивается так, что все элементы меньше опорного перемещаются слева от него, а все большие - справа

Опорный элемент занимает свою окончательную позицию

**Рекурсивная сортировка:**

Рекурсивно применяется к левой и правой частям относительно опорного элемента

**Рекурсивная структура:** quick_sort вызывает себя для левой и правой частей

**Разбиение Ломуто:** используется схема разбиения где i отслеживает позицию для вставки меньших элементов

**In-place сортировка:** массив сортируется на месте без создания копий

**Временная сложность:** 

**Лучший случай:** O(n log n) - когда опорный элемент делит массив пополам

**Средний случай:** O(n log n)

**Худший случай:** O(n²) - когда массив уже отсортирован или опорный элемент минимальный/максимальный

**Определение:**

**Пирамидальная сортировка** — алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.

**Анализ:**

**Построение max-heap:** Преобразуем массив в максимальную кучу, где корень всегда больше дочерних элементов

**Извлечение элементов:** Последовательно извлекаем максимальный элемент и перестраиваем кучу

**Метод heapify(arr, n, i):**

Поддерживает свойство кучи для поддерева с корнем i

Сравнивает корень с левым и правым дочерними элементами

Если нарушено свойство кучи - меняет местами и рекурсивно вызывает heapify

**Метод heapSort(arr):**

**Первый цикл:** построение max-heap (вызов heapify для всех нелистовых узлов)

**Второй цикл:** извлечение элементов и перестроение кучи

**Временная сложность:** 

**Построение кучи:** O(n)
**Извлечение элементов:** O(n log n)
**Общая сложность:** O(n log n) во всех случаях

**Определение:**

**Последовательный (линейный) поиск** — простейший вид поиска заданного элемента на некотором множестве. Осуществляется путём последовательного сравнения очередного рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут. Этот метод является наименее эффективным, так как его временная сложность составляет O(n), где n — количество элементов в списке. Однако он прост в реализации и может быть полезен для небольших списков или в тех случаях, когда данные не отсортированы.

**Анализ:**

**Последовательный просмотр:** Алгоритм проходит по всем элементам массива от начала до конца

**Поэлементное сравнение:** Каждый элемент сравнивается с искомым значением target

**Завершение при нахождении:** Как только найден совпадающий элемент, возвращается его индекс

**Завершение при отсутствии:** Если весь массив пройден и элемент не найден, возвращается -1

**Временная сложность:** 

**Лучший случай:** O(1) - элемент первый в массиве

**Средний случай:** O(n) - элемент в середине массива

**Худший случай:** O(n) - элемента нет или он последний

**Определение:**

**Бинарный (двоичный, дихотомический) поиск** — это поиск заданного элемента на упорядоченном множестве, осуществляемый путём неоднократного деления этого множества на две части таким образом, что искомый элемент попадает в одну из этих частей. Поиск заканчивается при совпадении искомого элемента с элементом, который является границей между частями множества или при отсутствии искомого элемента. Преимуществом бинарного поиска является более низкая трудоёмкость по сравнению с последовательным поиском. Недостаток заключается в том, что он применим только на отсортированных множествах.

**Анализ:**

**Определение границ:** Устанавливаются начальные границы поиска (left = 0, right = len(array) - 1)

**Поиск середины:** На каждой итерации находится средний элемент массива

**Сравнение с целевым значением:**

Если средний элемент равен целевому - поиск завершен

Если средний элемент больше целевого - поиск продолжается в левой половине

Если средний элемент меньше целевого - поиск продолжается в правой половине

**Сужение области поиска:** Границы постоянно сужаются до тех пор, пока элемент не будет найден или границы не пересекутся

**Цикл while:** while left <= right: - продолжается пока границы не пересекутся

**Безопасное вычисление середины:** mid = left + (right - left) // 2 - избегает переполнения

**Временная сложность:**  O(log n)

**Определение:**

**Интерполирующий поиск** — это алгоритм поиска для отсортированных наборов данных, таких как массивы или списки. Он предсказывает позицию нужного элемента на основе разницы значений. Эффективен, если элементы распределены достаточно равномерно.

**Анализ:**

**Проверка границ:** Убеждается, что искомый элемент находится в пределах массива x >= arr[lo] && x <= arr[hi]

**Вычисление позиции:** Использует формулу интерполяции для предсказания позиции элемента

**Рекурсивный поиск:** В зависимости от сравнения элемента в вычисленной позиции с искомым значением, продолжает поиск в левой или правой части

**Временная сложность:**

**Лучший случай:** O(log log n) - при равномерном распределении

**Средний случай:** O(log log n)

**Худший случай:** O(n) - при неравномерном распределении

**Определение:**

**Поиск по Фибоначчи** — это эффективный алгоритм поиска, используемый для нахождения целевого значения в отсортированной коллекции, такой как массив или список. По принципу он аналогичен бинарному поиску, но использует числа Фибоначчи для определения позиций для сравнения.

**Анализ:**

**Инициализация чисел Фибоначчи:** Находим наименьшее число Фибоначчи, большее или равное длине массива

**Поиск с использованием чисел Фибоначчи:** Используем числа Фибоначчи для определения позиций сравнения

**Сужение области поиска:** В зависимости от результата сравнения, переходим к левому или правому подмассиву

**Временная сложность:**  O(log n), как и у бинарного поиска, но с другим коэффициентом



